## 事务的概念
满足ACID特性的一组操作,可以通过Commit提交一个事务,也可以使用Rollback进行回滚

## ACID

原子性 简单来说就是事务被视为不可分割的最小单元 ,要么全部成功要么全部失败回滚
一致性 一致性状态下,所有十五对同一个数据的读取结果相同
隔离性 一个事务所作的修改在最终提交之前,对其他事务是不可见的
持久性 一旦事务提交 所做的修改就会永远的保存到数据库上去

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

只有满足一致性，事务的执行结果才是正确的。
在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
事务满足持久化是为了能应对系统崩溃的情况。
![关于事务性质的图片]() 



并发一致性会出现的问题 

数据丢失
T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

读脏数据
T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

不可重复读
T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。


并发会产生这些问题的原因就是破环了事务的隔离性,解决方法是通过并发控制 来保证隔离性 并发控制可以通过封锁来实现,但是封锁操作需要用户自己控制很复杂      
数据库提供了事务的隔离级别 ,让用户以一种简单的方式处理一致性的问题



一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。

另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。

在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。 
在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：

快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外)
	select * from table where ?; 
	1
	当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。 
	下面语句都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。

	```
	select * from table where ? lock in share mode;
	select * from table where ? for update;
	insert into table values (…);
	update table set ? where ?;
	delete from table where ?;
```

	数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏 感，可能更关心数据并发访问的能力。

	为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡 “隔离”与“并发”的矛盾。下表很好地概括了这4个隔离级别的特性。 
关于这个问题我们要解决的三个问题 

![图片的注意事项](<++>) <++>

1 X锁  S锁   IS锁  IX锁   这几种锁结合是如何解决上面的问题的
明白了晚上总结一下



2 数据库设计满足的范式要求   一范式 1NF  二范式  三范式等等

一范式 属性 不可分割 不能出现一个属性后面再出现两个属性

二范式   每个非主属性完全函数依赖于件吗
分解前
| Sno | Sname  | Sdept  | Mname  | Cname  | Grade |
|-----|--------|--------|--------|--------|-------|
| 1   | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90    |
| 2   | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80    |
| 2   | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100   |
| 3   | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95    |

三范式 


3 ER图

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：

    Sno -> Sname, Sdept
    Sdept -> Mname
    Sno, Cname-> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

分解后

关系-1
| Sno | Sname  | Sdept  | Mname  |
|-----|--------|--------|--------|
| 1 | 学生-1 | 学院-1 | 院长-1 |
| 2 | 学生-2 | 学院-2 | 院长-2 |
| 3 | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖：

    Sno -> Sname, Sdept
    Sdept -> Mname

关系-2
| Sno | Cname  | Grade |
|-----|--------|-------|
| 1 | 课程-1 | 90  |
| 2 | 课程-2 | 80  |
| 2 | 课程-1 | 100 |
| 3 | 课程-2 | 95  |

有以下函数依赖：

    Sno, Cname -> Grade

3. 第三范式 (3NF)

非主属性不传递函数依赖于键码。

上面的 关系-1 中存在以下传递函数依赖：

    Sno -> Sdept -> Mname

可以进行以下分解：

关系-11
| Sno | Sname  | Sdept  |
|-----|--------|--------|
| 1 | 学生-1 | 学院-1 |
| 2 | 学生-2 | 学院-2 |
| 3 | 学生-3 | 学院-2 |

关系-12
| Sdept  | Mname  |
|--------|--------|
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |
